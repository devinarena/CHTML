
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "compiler.h"

/**
 * @file compiler.c
 * @author Devin Arena
 * @brief Logic for compiling tokens generated by the scanner into HTML code.
 * @since 10/30/2022
 **/

Compiler compiler;

static void expression();

/**
 * @brief Writes a string to a file. Called once the compiler has finished
 * generating HTML.
 *
 * @param file the file to write to.
 */
static void writeOutput(char* file) {
  FILE* f = fopen(file, "w");
  if (f == NULL) {
    printf("Error opening file!\n");
    exit(1);
  }

  int outputSize = strlen(compiler.output);
  compiler.output = (char*)realloc(compiler.output, outputSize + 1);
  compiler.output[outputSize] = '\0';

  fprintf(f, "%s", compiler.output);
  fclose(f);
}

/**
 * @brief Adds output to the compiler's output buffer. Contains the HTML
 * generated by the compiler.
 *
 * @param str the string to add to the output buffer.
 * @param freeMemory whether or not to free the memory allocated to the string.
 */
static void addOutput(char* str) {
  int len = strlen(str);
  if (!compiler.output) {
    compiler.output = malloc(len * sizeof(char*));
    strcpy(compiler.output, str);
  } else {
    int oldLen = strlen(compiler.output);
    compiler.output = realloc(compiler.output, (oldLen + len) * sizeof(char*));
    strcat(compiler.output, str);
  }
}

/**
 * @brief Displays a compilation error before terminating the program.
 *
 * @param message the error message to display.
 */
static void compileError(char* message) {
  printf("Compile error: %s", message);
  exit(1);
}

/**
 * @brief Pushes a token onto the token stack. (for closing tags)
 *
 * @param token the token to push onto the stack.
 */
static void pushStack(Token token) {
  *(compiler.stackTop++) = token;
}

/**
 * @brief Pops a token off the stack and returns it.
 *
 * @return Token the token that was popped off the stack.
 */
static Token popStack() {
  return *(--compiler.stackTop);
}

/**
 * @brief Returns the token at the top of the stack without removing it.
 *
 * @param depth the depth of the token to return.
 * @return Token the token at a depth of 'depth'.
 */
static Token peekStack(int depth) {
  return *(compiler.stackTop - depth - 1);
}

/**
 * @brief Advances the compiler to the next token (assigning the previous
 * token).
 */
static void advance() {
  compiler.previous = compiler.current;
  compiler.current = scanToken();
}

/**
 * @brief Checks for a token, errroring out a message if the token is not found.
 *
 * @param type the type of token to check for.
 * @param message the error message to display if the token is not found.
 */
static void consume(TokenType type, char* message) {
  if (compiler.current.type == type) {
    advance();
    return;
  }

  compileError(message);
}

/**
 * @brief Checks if the current token is of a certain type.
 *
 * @param type the type of token to check for.
 * @return bool if the current token is of type 'type'.
 */
static bool match(TokenType type) {
  if (compiler.current.type == type) {
    advance();
    return true;
  }
  return false;
}

/**
 * @brief Removes quotes from a string. Used to remove quotes from attribute
 * values. ALLOCATES A NEW STRING THAT MUST BE FREED.
 *
 * @param str the string to remove quotes from.
 * @param len the length of the string.
 * @return char* the string with quotes removed. Must be freed.
 */
static char* removeQuotes(char* str, int len) {
  char* newStr = malloc((len - 1) * sizeof(char*));
  strncpy(newStr, str + 1, len - 1);
  newStr[len - 1] = '\0';
  return newStr;
}

/**
 * @brief Generate closing tags for any open tags still on the stack.
 *
 * @param tabs the indentation level of which to stop generating closing tags.
 */
static void finishTags(int tabs) {
  while (compiler.stackTop - compiler.stack > 0 && peekStack(0).tab >= tabs) {
    Token token = popStack();
    switch (token.type) {
      case TOKEN_DOCUMENT:
        addOutput("</html>");
        break;
      case TOKEN_CONTAINER:
        addOutput("</div>");
        break;
      case TOKEN_HEAD:
        addOutput("</head>");
        break;
      case TOKEN_BODY:
        addOutput("</body>");
        break;
    }
  }
}

static void text() {
  Token text = compiler.previous;
  printf("%*c", 6, ' ');
  printToken(text);
  if (text.type != TOKEN_TEXT) {
    compileError("Expected text after text-tag token");
  }

  char* output = removeQuotes(text.start, text.length);
  addOutput(output);
  free(output);
}

/**
 * @brief Descent case for tokens with text content (title tag, paragraph tag,
 * etc.)
 *
 * @param tagName the tag to open and close around the text
 */
static void textTag(char* tagName) {
  int len = snprintf(NULL, 0, "<%s>", tagName);

  char* open = malloc(len);
  sprintf(open, "<%s>", tagName);

  addOutput(open);

  expression();

  char* close = malloc(len + 1);
  sprintf(close, "</%s>", tagName);
  addOutput(close);
  // free(output);
}

/**
 * @brief Descent case for headings (h1-h6)
 *
 * @param headingType the type of heading (h1-h6)
 */
static void heading() {
  char* heading = malloc(sizeof(char*) * 2);
  sprintf(heading, "h%d", compiler.previous.type - TOKEN_HEADING1 + 1);
  textTag(heading);
  free(heading);
}

/**
 * @brief Descent case for container type tags (document, div, head, body)
 */
static void container() {
  Token token = compiler.previous;

  char* tagName;

  switch (token.type) {
    case TOKEN_DOCUMENT:
      tagName = "html";
      break;
    case TOKEN_CONTAINER:
      tagName = "div";
      break;
    case TOKEN_HEAD:
      tagName = "head";
      break;
    case TOKEN_BODY:
      tagName = "body";
      break;
    default:
      compileError("Expected container type.");
  }

  // Sloppy and should probably be fixed, used for css
  if (match(TOKEN_LEFT_PAREN)) {
    consume(TOKEN_TEXT, "Expected text of css inside css block specifier.");
    char* css = removeQuotes(compiler.previous.start, compiler.previous.length);
    int len = snprintf(NULL, 0, "<%s style=\"%s\">", token.start, css);
    char* open = malloc(len);
    sprintf(open, "<%s style=\"%s\">", tagName, css);
    addOutput(open);
    free(css);
    free(open);
    pushStack(token);
    consume(TOKEN_RIGHT_PAREN, "Unexpected end of css block specifier.");
    return;
  } else {
    int len = snprintf(NULL, 0, "<%s>", tagName);
    char* open = malloc(len);
    sprintf(open, "<%s>", tagName);
    addOutput(open);
    free(open);
    pushStack(token);
    return;
  }

  pushStack(token);
}

/**
 * @brief Descent case for css tags, right now just used to link and insert css
 * eventually will add support for custom properties.
 */
static void cssTag() {
  if (peek() == '\n') {
    return;
  }
  advance();

  Token path = compiler.previous;
  if (path.type != TOKEN_TEXT) {
    compileError("Expected path after css-tag token");
  }
  printf("%*c", 6, ' ');
  printToken(path);

  char* output = removeQuotes(path.start, path.length);

  const char* template = "<link rel=\"stylesheet\" href=\"%s\" />";

  int len = snprintf(NULL, 0, template, output);

  char* open = malloc(len);
  sprintf(open, template, output);
  addOutput(open);
  free(output);
  free(open);
}

static void macro() {
  printf("%*c", 6, ' ');
  printToken(compiler.previous);  // Print the macro token
  advance();

  Token name = compiler.previous;
  if (name.type != TOKEN_IDENTIFIER) {
    compileError("Expected name after macro token");
  }
  printf("%*c", 6, ' ');
  printToken(name);

  char* key = malloc(name.length + 1);
  strncpy(key, name.start, name.length);
  key[name.length] = '\0';

  char* value = tableGet(&compiler.macros, key);
  if (value == NULL) {
    compileError("Undefined macro");
  }
  addOutput(value);

  free(key);
}

static void expression() {
  advance();

  switch (compiler.previous.type) {
    case TOKEN_EXCLAMATION:
      macro();
      break;
    case TOKEN_TEXT:
      text();
      break;
    default:
      compileError("Expected expression");
      break;
  }
}

/**
 * @brief Base descent case for statements.
 */
static void statement() {
  Token token = compiler.previous;

  switch (token.type) {
    case TOKEN_DOCUMENT:
    case TOKEN_CONTAINER:
    case TOKEN_HEAD:
    case TOKEN_BODY:
      container();
      break;
    case TOKEN_HEADING1:
    case TOKEN_HEADING2:
    case TOKEN_HEADING3:
    case TOKEN_HEADING4:
    case TOKEN_HEADING5:
    case TOKEN_HEADING6:
      heading();
      break;
    case TOKEN_TITLE:
      textTag("title");
      break;
    case TOKEN_PARAGRAPH:
      textTag("p");
      break;
    case TOKEN_CSS:
      cssTag();
      break;
    case TOKEN_RAW_HTML: {
      char* output = malloc(token.length - 2);
      memcpy(output, token.start + 1, token.length - 2);
      addOutput(output);
      free(output);
      break;
    }
    default:
      expression();
      break;
  }
  compiler.instruction++;
}

/**
 * @brief Zeroes out the compilers memory.
 */
void initCompiler() {
  compiler.stackTop = compiler.stack;
  compiler.output = NULL;
  compiler.instruction = 0;
  initTable(&compiler.macros);
}

/**
 * @brief Compiles the file into HTML.
 */
void compile() {
  addOutput("<!DOCTYPE html>");

  tableSet(&compiler.macros, "pi", "3.14159");

  compiler.current = scanToken();

  while (compiler.current.type != TOKEN_EOF) {
    advance();

    printf("%.4d: ", compiler.instruction);
    printToken(compiler.previous);

    finishTags(compiler.previous.tab);

    statement(compiler.previous);
  }
  printf("%.4d: ", compiler.instruction);
  printToken(compiler.current);

  finishTags(0);

  writeOutput("index.html");
}