
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "compiler.h"

/**
 * @file compiler.c
 * @author Devin Arena
 * @brief Logic for compiling tokens generated by the scanner into HTML code.
 * @since 10/30/2022
 **/

Compiler compiler;

/**
 * @brief Writes a string to a file. Called once the compiler has finished
 * generating HTML.
 *
 * @param file the file to write to.
 */
static void writeOutput(char* file) {
  FILE* f = fopen(file, "w");
  if (f == NULL) {
    printf("Error opening file!\n");
    exit(1);
  }

  int outputSize = strlen(compiler.output);
  compiler.output = (char*)realloc(compiler.output, outputSize + 1);
  compiler.output[outputSize] = '\0';

  fprintf(f, "%s", compiler.output);
  fclose(f);
}

/**
 * @brief Adds output to the compiler's output buffer. Contains the HTML
 * generated by the compiler.
 *
 * @param str the string to add to the output buffer.
 * @param freeMemory whether or not to free the memory allocated to the string.
 */
static void addOutput(char* str) {
  int len = strlen(str);
  if (!compiler.output) {
    compiler.output = malloc(len * sizeof(char*));
    strcpy(compiler.output, str);
  } else {
    int oldLen = strlen(compiler.output);
    compiler.output = realloc(compiler.output, (oldLen + len) * sizeof(char*));
    strcat(compiler.output, str);
  }
}

/**
 * @brief Displays a compilation error before terminating the program.
 *
 * @param message the error message to display.
 */
static void compileError(char* message) {
  printf("Compile error: %s", message);
  exit(1);
}

/**
 * @brief Pushes a token onto the token stack. (for closing tags)
 *
 * @param token the token to push onto the stack.
 */
static void pushStack(Token token) {
  *(compiler.stackTop++) = token;
}

/**
 * @brief Pops a token off the stack and returns it.
 *
 * @return Token the token that was popped off the stack.
 */
static Token popStack() {
  return *(--compiler.stackTop);
}

static Token peekStack(int depth) {
  return *(compiler.stackTop - depth - 1);
}

/**
 * @brief Removes quotes from a string. Used to remove quotes from attribute
 * values. ALLOCATES A NEW STRING THAT MUST BE FREED.
 *
 * @param str the string to remove quotes from.
 * @param len the length of the string.
 * @return char* the string with quotes removed. Must be freed.
 */
static char* removeQuotes(char* str, int len) {
  char* newStr = malloc((len - 1) * sizeof(char*));
  strncpy(newStr, str + 1, len - 1);
  newStr[len - 1] = '\0';
  return newStr;
}

/**
 * @brief Generate closing tags for any open tags still on the stack.
 *
 * @param tabs the indentation level of which to stop generating closing tags.
 */
static void finishTags(int tabs) {
  while (compiler.stackTop - compiler.stack > 0 && peekStack(0).tab >= tabs) {
    Token token = popStack();
    switch (token.type) {
      case TOKEN_DOCUMENT:
        addOutput("</html>");
        break;
      case TOKEN_CONTAINER:
        addOutput("</div>");
        break;
      case TOKEN_HEAD:
        addOutput("</head>");
        break;
      case TOKEN_BODY:
        addOutput("</body>");
        break;
    }
  }
}

/**
 * @brief Descent case for tokens with text content (title tag, paragraph tag,
 * etc.)
 *
 * @param tagName the tag to open and close around the text
 */
static void textTag(char* tagName) {
  Token text = scanToken();
  printf("%*c", 6, ' ');
  printToken(text);
  if (text.type != TOKEN_TEXT) {
    compileError("Expected text after text-tag token");
  }

  char* output = removeQuotes(text.start, text.length);

  int len = snprintf(NULL, 0, "<%s>", tagName);

  char* open = malloc(len);
  char* close = malloc(len + 1);
  sprintf(open, "<%s>", tagName);
  sprintf(close, "</%s>", tagName);
  addOutput(open);
  addOutput(output);
  addOutput(close);
  free(output);
}

/**
 * @brief Descent case for headings (h1-h6)
 *
 * @param headingType the type of heading (h1-h6)
 */
static void heading(TokenType headingType) {
  char* heading = malloc(sizeof(char*) * 2);
  sprintf(heading, "h%d", headingType - TOKEN_HEADING1 + 1);
  textTag(heading);
  free(heading);
}

/**
 * @brief Descent case for container type tags (document, div, head, body)
 *
 * @param token the token to descend on.
 */
static void container(Token token) {
  switch (token.type) {
    case TOKEN_DOCUMENT:
      addOutput("<html>");
      break;
    case TOKEN_CONTAINER:
      addOutput("<div>");
      break;
    case TOKEN_HEAD:
      addOutput("<head>");
      break;
    case TOKEN_BODY:
      addOutput("<body>");
      break;
    default:
      compileError("Expected container type.");
  }

  pushStack(token);
}

/**
 * @brief Descent case for css tags, right now just used to link and insert css
 * eventually will add support for custom properties.
 */
static void cssTag() {
  if (peek() == '\n') {
    return;
  }
  Token path = scanToken();
  if (path.type != TOKEN_TEXT) {
    compileError("Expected path after css-tag token");
  }
  printf("%*c", 6, ' ');
  printToken(path);

  char* output = removeQuotes(path.start, path.length);

  const char* template = "<link rel=\"stylesheet\" href=\"%s\" />";

  int len = snprintf(NULL, 0, template, output);

  char* open = malloc(len);
  sprintf(open, template, output);
  addOutput(open);
  free(output);
  free(open);
}

/**
 * @brief Base descent case for statements.
 *
 * @param token the token to descend on.
 */
static void statement(Token token) {
  switch (token.type) {
    case TOKEN_DOCUMENT:
    case TOKEN_CONTAINER:
    case TOKEN_HEAD:
    case TOKEN_BODY:
      container(token);
      break;
    case TOKEN_HEADING1:
    case TOKEN_HEADING2:
    case TOKEN_HEADING3:
    case TOKEN_HEADING4:
    case TOKEN_HEADING5:
    case TOKEN_HEADING6:
      heading(token.type);
      break;
    case TOKEN_TITLE:
      textTag("title");
      break;
    case TOKEN_PARAGRAPH:
      textTag("p");
      break;
    case TOKEN_CSS:
      cssTag();
      break;
    case TOKEN_RAW_HTML: {
      char* output = malloc(token.length - 2);
      memcpy(output, token.start + 1, token.length - 2);
      addOutput(output);
      free(output);
      break;
    }
    default:
      compileError("Expected statement.");
      break;
  }
  compiler.instruction++;
}

/**
 * @brief Zeroes out the compilers memory.
 */
void initCompiler() {
  compiler.stackTop = compiler.stack;
  compiler.output = NULL;
  compiler.instruction = 0;
}

/**
 * @brief Compiles the file into HTML.
 */
void compile() {
  addOutput("<!DOCTYPE html>");

  Token current = scanToken();

  while (current.type != TOKEN_EOF) {
    printf("%.4d: ", compiler.instruction);
    printToken(current);

    finishTags(current.tab);

    statement(current);

    current = scanToken();
  }
  printf("%.4d: ", compiler.instruction);
  printToken(current);

  finishTags(0);

  writeOutput("index.html");
}